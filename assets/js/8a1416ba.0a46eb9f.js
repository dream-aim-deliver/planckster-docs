"use strict";(self.webpackChunkplanckster_docs=self.webpackChunkplanckster_docs||[]).push([[7699],{5240:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>h,frontMatter:()=>s,metadata:()=>o,toc:()=>l});var a=n(4848),r=n(8453);const s={sidebar_label:"Architecture Overview",sidebar_position:2},i="Planckster Ecosystem - Architecture Overview",o={id:"concepts/architecture",title:"Planckster Ecosystem - Architecture Overview",description:"The Planckster Ecosystem consists of four interconnected components that work together to provide you with filtered, debugged, and processed data on topics relevant to your needs. This data is ready for you to explore, analyze, and utilize for various applications.",source:"@site/docs/concepts/architecture.md",sourceDirName:"concepts",slug:"/concepts/architecture",permalink:"/docs/concepts/architecture",draft:!1,unlisted:!1,editUrl:"https://github.com/dream-aim-deliver/planckster-docs/edit/main/docs/concepts/architecture.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_label:"Architecture Overview",sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Introduction",permalink:"/docs/concepts/core-concepts/"},next:{title:"Disaster Tracking Usecase",permalink:"/docs/concepts/disaster-tracking-usecase"}},c={},l=[{value:"Kernel Planckster",id:"kernel-planckster",level:2},{value:"Data Scrapers",id:"data-scrapers",level:2},{value:"Lieutenant Planckster",id:"lieutenant-planckster",level:2},{value:"Webstat Planckster",id:"webstat-planckster",level:2},{value:"Architecture Overview",id:"architecture-overview",level:2}];function d(e){const t={a:"a",h1:"h1",h2:"h2",p:"p",strong:"strong",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.h1,{id:"planckster-ecosystem---architecture-overview",children:"Planckster Ecosystem - Architecture Overview"}),"\n",(0,a.jsx)(t.p,{children:"The Planckster Ecosystem consists of four interconnected components that work together to provide you with filtered, debugged, and processed data on topics relevant to your needs. This data is ready for you to explore, analyze, and utilize for various applications."}),"\n",(0,a.jsxs)(t.p,{children:["The four key components of the Planckster architecture are: 1) ",(0,a.jsx)(t.strong,{children:"Kernel Planckster"}),", 2) ",(0,a.jsx)(t.strong,{children:"Data Scrapers"}),", 3) ",(0,a.jsx)(t.strong,{children:"Lieutenant Planckster"}),", and 4) ",(0,a.jsx)(t.strong,{children:"Websat Planckster"}),". These elements collaborate to gather vast amounts of data from relevant web pages, process it to suit your specific requirements, and store it for you to download, analyze, and apply as needed. Ultimately, this empowers you to make well-informed decisions based on accurate and relevant information."]}),"\n",(0,a.jsx)(t.h2,{id:"kernel-planckster",children:"Kernel Planckster"}),"\n",(0,a.jsx)(t.p,{children:"Kernel Planckster is the central data management system within the Planckster ecosystem. It performs two primary functions: 1) receiving and storing information provided by the scrapers or the client, and 2) retrieving this stored information for your analysis. It manages the Metadata Database, where the attributes of received data are recorded, and the Block Storage element, where the actual data is stored."}),"\n",(0,a.jsx)(t.p,{children:"You can interact with Kernel Planckster to request the extraction of relevant data from the internet or to download stored data through the Lieutenant Planckster platform on Kubeflow."}),"\n",(0,a.jsxs)(t.p,{children:["For more information on Kernel Planckster and how to use Kernel Planckster REST API, refer to the ",(0,a.jsx)(t.a,{href:"../category/kernel-planckster",children:"Kernel Planckster Guides"}),"."]}),"\n",(0,a.jsx)(t.h2,{id:"data-scrapers",children:"Data Scrapers"}),"\n",(0,a.jsx)(t.p,{children:"A Data Scraper is a program that automatically extracts relevant data from websites. There are three scrapers that are already set up in the Planckster Ecosystem: a Telegram scraper, a Twitter scraper and a Sentinel scraper (in future versions, more scrapers can be added). These scrapers retrive information from its corresponding website and then send the information to the Kernel Planckster software, which registers it in the Metadata database and saves it in the Block Storage element. The scraper can also augment the data using AI and LLM algorithms before sending it to Kernel Planckster."}),"\n",(0,a.jsxs)(t.p,{children:["For more information on how the data scrapers work, refer to the ",(0,a.jsx)(t.a,{href:"/docs/concepts/scrapers",children:"Data Scrapers core concept document"}),"."]}),"\n",(0,a.jsx)(t.h2,{id:"lieutenant-planckster",children:"Lieutenant Planckster"}),"\n",(0,a.jsx)(t.p,{children:"Lieutenant Planckster is a pipeline builder hosted on the Kubeflow platform. Pipelines are where all the different components - including code and images stored remotely - are pulled together into a workflow. Lieutenant Planckster functions as the control center, allowing users to interact with or issue commands to Kernel Planckster. These commands, written in code, when executed in the pipeline executor, trigger Kernel Planckster to perform its tasks. For instance, you can run the pre-configured scraper pipeline in Kubeflow to activate the scrapers and simultaneously retrieve data from sources like Telegram, Twitter, and Sentinel, storing it in the Block Storage element. The key inputs you need to provide to execute a pipeline is the tracer_id and the job_id as these are key to create the path where your data will be storage in Kernel Planckster."}),"\n",(0,a.jsxs)(t.p,{children:["For more information on Lieutenant Planckster, refer to the ",(0,a.jsx)(t.a,{href:"../category/lieutenant-planckster",children:"Lieutenant Planckster Guides"}),"."]}),"\n",(0,a.jsx)(t.h2,{id:"webstat-planckster",children:"Webstat Planckster"}),"\n",(0,a.jsx)(t.p,{children:"After executing the commands to scrape and save data in Kernel Planckster, you can analyze and interact with it using Python SDK, Jypyter Notebooks or Websat. Websat is a web interface designed to facilitate interaction with the Planckster ecosystem, allowing you to visualize and download scraped data. It also enables you to create conversations with your data and engage with LLM agents, focusing on data analysis and visualization. The first version of Websat, introduced in November 2023, showcased the LLM's data analysis capabilities. The current version, now in Beta, demonstrates its enhanced features for data upload, download, and visualization."}),"\n",(0,a.jsx)(t.h2,{id:"architecture-overview",children:"Architecture Overview"}),"\n",(0,a.jsx)(t.p,{children:"This is how the Planckster Ecosystem functions as an articulated system. At its core is Kernel Planckster, which manages the flow of information based on client commands. Kernel Planckster manages both the Metadata Database and the Block Storage element, where it stores and organizes the data it handles. Kernel Planckster, the Metadata Database and the Block Storage element can be seen as one integrated element as neither can exist without the other two."}),"\n",(0,a.jsx)(t.p,{children:"The ecosystem also includes scrapers for platforms like Telegram, Twitter, and Sentinel, responsible for retrieving data from their respective servers and transmitting it to Kernel Planckster."}),"\n",(0,a.jsx)(t.p,{children:"The data scraping process and workflow are determined by the pipelines that clients can create and run on the Lieutenant Planckster Kubeflow platform. When a pipeline is executed in the pipeline executor, the scrapers begin retrieving data and sending it to Kernel Planckster in the specified sequence. Kernel Planckster then saves the data in a unique location according to the tracer_id and job_id the client defines. Finally, the client can use Websat Planckster to visualize, analyze, and download the scraped data."})]})}function h(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>i,x:()=>o});var a=n(6540);const r={},s=a.createContext(r);function i(e){const t=a.useContext(s);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),a.createElement(s.Provider,{value:t},e.children)}}}]);